В организации было решено ввести справочник подразделений.

Коды подразделений представлены в виде массива строк вида:

"K1/SK1"
"K1/SK2"
"K1/SK1/SSK1"
"K1/SK1/SSK2"
"K2"
"K2/SK1/SSK1"
"K2/SK1/SSK2"
, где каждая строка имеет следующую структуру: код текущего подразделения, а перед ним коды всех более крупных подразделений
(к примеру департамент K1 включает в себя службу SK1, включающую в себя отдел SSK1).
Подразделения в одной строке разделены знаком "/". Возможны случаи, когда в массиве отсутствуют строки с кодом
вышестоящего подразделения (в показанном выше массиве есть строки с подразделением K1, но данный код подразделения
не представлен отдельной строкой "K1", аналогичный случай с кодом "K2/SK1"), в таком случае необходимо добавить строку
с кодом данного подразделения и учитывать ее при сортировке.

Необходимо разработать класс, который будет добавлять пропущенные подразделения, а также производить сортировку подразделений.

Чтобы реализовать метод fillGaps, нужно определить, какие элементы отсутствуют в системе.
Для этого каждую входящую строку нужно разбить на одиночные элементы.
 Для этого можно использовать метод String.split("/"). Этот метод вернет массив одиночных элементов.
 Далее нужно через цикл последовательно складывать элементы и добавлять их в множество.
 Используйте в качестве промежуточного хранения LinkedHashSet.

public static List<String> fillGaps(List<String> deps) {
    Set<String> tmp = new LinkedHashSet<>();
    for (String value : deps) {
        String start = "";
        for (String el : value.split("/")) {
            /* tmp.add start + "/" + el */
        }
    }
    return new ArrayList<>(tmp);
}
Промежуточная коллекция LinkedHashSet позволяет устранить дубликаты из коллекции, которые будут получаться в результате
 последовательного складывания единичных департаментов. При этом данные в LinkedHashSet будут отсортированы в том
 порядке, в котором они добавляются в LinkedHashSet.
Так же в задаче требуется реализовать возможность сортировки массива кодов подразделений по возрастанию и убыванию,
при которых сохранялась бы иерархическая структура (показано далее в примерах сортировки), т.к. отсортированный массив
используется для отображения категорий пользователю. Отсортированный тестовый массив должен иметь следующий вид. Жирным
отмечены департаменты, которые мы выделили из исходного списка.

Сортировка по возрастанию:
"K1"
"K1/SK1"
"K1/SK1/SSK1"
"K1/SK1/SSK2"
"K1/SK2"
"K2"
"K2/SK1"
"K2/SK1/SSK1"
"K2/SK1/SSK2"

Эта классическая сортировка по возрастанию - Comparator.naturalOrder().

Сортировка по убыванию:
"K2"
"K2/SK1"
"K2/SK1/SSK1"
"K2/SK1/SSK2"
"K1"
"K1/SK1"
"K1/SK1/SSK1"
"K1/SK1/SSK2"
"K1/SK2"

В этом случае сортировка имеет сложный вид. Нам нужно сравнить первые элементы по убыванию, если они равны,
то сравнить последующие элементы, но в возрастающем порядке.

Для сортировки по убыванию реализуйте отдельный компаратор.
package ru.job4j.collection;

import java.util.Comparator;

public class DepDescComp implements Comparator<String> {
    @Override
    public int compare(String o1, String o2) {
        return 0;
    }
}
Отдельно напишем на него тест-класс.

package ru.job4j.collection;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.hamcrest.Matchers.greaterThan;

public class DepDescCompTest {

    @Test
    public void compare() {
        int rsl = new DepDescComp().compare(
                "K2/SK1/SSK2",
                "K2/SK1/SSK1"
        );
        assertThat(rsl, greaterThan(0));
    }

    @Test
    public void whenUpDepartmentGoBefore() {
        int rsl = new DepDescComp().compare(
                "K2",
                "K2/SK1"
        );
        assertThat(rsl, lessThan(0));
    }
}
Задание.
1. Реализуйте класс Departments.
2. Напишите на него тесты.
3. Залейте код в репозиторий и переведите ответственного на Петра Арсентьева.